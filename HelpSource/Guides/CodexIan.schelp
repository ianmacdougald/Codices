TITLE::CodexIan Guide
summary::Guide to working with the library CodexIan
categories::Libraries>CodexIan
related::Overviews/CodexIan, Guides/CodexProxier
keyword::hybrid, composite, composition

section::Description
CodexIan establishes a framework for developing modular class interfaces in sclang using arbitrarily defined scriptable components. For instance, a class written in this framework that iteratively evaluates a function within a routine might implement only the routine, leaving the function itself to be defined later by the user. As a result, an object of this class can support any number of diverse configurations without compromising the functionality of the class itself. As such, the framework aims to support a best-of-both-worlds situation that balances the specifity of a compiled class's interface with the open-ended potential of scripting.

link::Classes/CodexComposite:: coordinates these operations and maintains a directory of sets of modules on behalf of its subclasses. link::Classes/CodexHybrid:: inherits from CodexComposite, handling the process of adding and removing link::Classes/SynthDef:: modules from a given server. 

section::Module directories

Each class that inherits from CodexComposite will have its modules stored in a central directory on the machine. The modules themselves are organized in layers of subfolders that are specified on a per-class-per-collection basis. The path to the directory can be gotten and set through link::Classes/CodexComposite#*directory::. If the path to the directory of modules is reset, the new configuration will persist across sessions of the link::Classes/Interpreter:: (see link::Classes/CodexStorage::).

note::Be sure to configure the path to the modules directory. By default, the module directory is stored in the folder of this quark.
code::
//Check where the directory is.
CodexComposite.directory.postln;

//Replace this path with something you prefer.
CodexComposite.directory = "~/Documents/scmodules".standardizePath;
::
::
An outline of the directory looks like this:

Module Directory
tree::
	##Class 0
		tree::
			##Module folder
				tree::
					##Module
					##Module
					##Module
				::
			##Module folder
				tree::
					##Module
					##Module
					##Module
				::
		::
	##Class 1
		tree::
			##Module folder
			tree::
				##Module
			::
		::
::

subsection::Class folders
Class folders are generated automatically. However, the circumstances regarding when that happens vary. For instance, a class that a contains reference to a preconfigured version of its modules will create both its class folder when sclang is recompiled as well as a subfolder populated with copies of these modules, and this process will be repeated if either of these folders is deleted. If no versions are specified, then once a class is instanced for the first time the framework will generate both the class folder and a folder of modules filled with templates. 

subsection::Module folders
Modules are stored as teletype::.scd:: files within the subfolders of each class folder; each of these subfolders contains variations of the modules templated by the class. As a result, a class expects that modules representing specific sclang objects exist but does not need to now emphasis::how:: they exist. As such, the module loaded from the file teletype::default/sequence.scd:: can be different from the one loaded from the file teletype::experimental/sequence.scd:: so long as both scripts return an object of the same type.

There is no prescribed limit to the number of modular variations that can exist per class. An instance of a subclass of CodexComposite is told to load one of these collections either by supplying a symbol to the teletype::moduleSet:: argument of link::Classes/CodexComposite#*new:: or by setting the value of the field link::Classes/CodexComposite#-moduleSet::. 
note::To see all available module sets, use the method link::Classes/CodexComposite#*moduleSets::.::
In both cases, the user has an opportunity to point to a different set of modules by supplying a second argument. In the case where the set of modules specified by the first argument does not exist but those specified by the second argument do, then a new set of modules will be copied from those pointed to by the second argument into a directory that can be later accessed with the symbol of the first argument. However, if this second set of modules is not specified or does not exist, then the new directory associated with the first argument's symbol will be filled with link::Classes/CodexTemplater##templates::.  

subsection::Modules
As stated above, modules are teletype::.scd:: files containing scripts that return an arbitrary object. When a set of modules is requested for the first time, these scripts are loaded into sclang, collected with an instance of link::Classes/CodexModules::, which is in turn stored in an instance of link::Classes/CodexCache::. Copies of the cached modules then can be accessed via link::Classes/CodexComposite#-modules::. CodexModules behaves like an link::Classes/IdentityDictionary:: where each module it stores is associated with a key derived from its respective file name . For instance, a pattern loaded from teletype::sequence.scd:: is accessible using the key \sequence. If the name of the file were teletype::SillySequence.scd::, its associated module would be accessed using the key \sillySequence.

Furthermore, if the source file of a module currently loaded into an instance of a CodexComposite-typed class is edited, calling link::Classes/CodexComposite#-reloadScripts:: will reload the objects from the scripts into the cache before copying them into the instance that called the method. Subsequently, all new instances that call for modules from that same collection will reflect these updates. To update currently existing instances, invoking link::Classes/CodexComposite#-reloadModules:: will refresh modules from the now modified cache. This process does not require recompiling sclang.

subsection::Contributing versions 
CodexComposite supports the ability to ship any of its subclasses class with sets of preconfigured modules. This is done by overwriting the method link::Classes/CodexComposite#*contribute#*contribute::, which is passed a link::Classes/List:: that must be supplied with an array of two items: a symbol or string representing the name of the set of modules to be cloned to the directory as well as the path where the modules are currently stored. Ideally, this path should be located within the folder of the project implementing the class. 

There are four short steps required to make a contribution: first, checkout a new branch of your clone of the project; second, add your version of the modules to the project folder; third, point to your projects by adding its name and path (in that order) as an array to the list of versions in the class's implementation; and finally, commit your changes to the branch and submit a pull request for the project. 

By implementing this framework as a platform that publishes diverse approaches common projects, my hope is to promote a collaborative music-making process that mirros the ethos of the libre/open-source software movements in which the SuperCollider project itself is developed. More information about the procedures by which one participates either with CodexIan-based projects or with SuperCollider can be found by visiting the following link: 
link::https://supercollider.github.io/contributing/::.

section::CompositeExample
Developing a class that inherits from CodexComposite is relatively simple. No constructor is needed. The only requirement is that the developer fill out the method link::Classes/CodexComposite#*makeTemplates::, which takes an instance of link::Classes/CodexTemplater:: as an argument. In fact, it is this method that defines the modules of a class. For instance, if you are making a class that requires a pattern that can be accessed via the key \sequence, then the templater instance must be told to generate a pattern with the name "sequence".

A basic implementation of a class that inherits from CodexComposite is displayed below. There, a single module — a pattern called "sequence" — is defined, and the class implements two other methods that play and stop the module.
code::
CompositeExample : CodexComposite {
	var player;
	
	//initComposite is called immediately after modules are loaded into the class. 
	//Initialize instance variables here if you don't want to rewrite the constructor.
	initComposite {}

	*makeTemplates { | templater | 
		templater.pattern( "sequence" );
	}

	play { 
		if(player.isPlaying.not, { 
			player = modules.sequence.play;
		});
	}

	stop { 
		if(player.isPlaying, { 
			player.stop;
		});
	}
}
::

subsection::Usage
Below represents code for interacting with the class whose implementation is displayed immediately above.
code::
x = CompositeExample.new(\version1);

//Insepct the modules.
x.modules.postln;

(
//A folder now exists in the directory.
var path = CodexComposite.directory;
PathName(path).folders.do({|item|
	item.folderName.postln;
});
)

(
//Inspecting that folder, see that an entry exists for \version1.
var path = CompositeExample.classFolder;
PathName(path).folders.do({|item|
	item.folderName.postln;
});
)

//This is easier done using the .moduleSets class method
CompositeExample.moduleSets;

//Open up the default script files to inspect them or make changes.
x.openModules; 

//If you want to make a new set of modules, that is easy.
x.moduleSet = \version2;

//There are now more moduleSets accessible to the class
CompositeExample.moduleSets.postln;
x.modules.postln;

//Open the \version2 set of modules.
//This method is only supported for the editors scide, scvim, and scnvim.
x.openModules; 

//If you edit them, load the changes back into the instance. 
x.reloadScripts; 

//You can switch back and forth between existing modules too.
x.moduleSet = \version1;

//If you want to make a new folder cloned from the \version2 one...
//edit the file in the \version2 folder, and clone it as follows:
x.moduleSet_(\version3, \version2);

//Open the new modules. Unless you edited \version2, the new modules will look like templates. 
x.openModules;
::

SECTION::CodexHybrid
CodexHybrid extends the procedures of CodexComposite to process SynthDef modules. It does this by reformatting their names to prevent clashes before sending each respective SynthDef to a given server. SynthDef modules will only be added to the server when unique collections of modules are added to the cache maintained by CodexComposite.

subsection::SynthDef naming
Consider the the case of a class that defines a SynthDef module template and inherits from CodexHybrid. For the sake of argument, let's imagine that this class is called teletype::GuideExample:: and that its set of modules, \fooBar, names its SynthDef \fooBarSound. If another set of modules, \fooBarClone, is copied from the first but contains a different version of its SynthDef, then loading both sets into the same server session would cause one version of the SynthDef to overwrite another. In other words, in this example both sets of modules cannot function independently. To address this problem, CodexHybrid forces each class to rename its SynthDef modules, appending the user-defined key with the name of both the modules' set and also the class itself. In this way, the hypothetical SynthDefs referred to above would be renamed \GuideExample_fooBar_fooBarSound and \GuideExample_fooBarClone_fooBarSound respectively. Once these sets of modules are loaded, the class will not re-add the associated SynthDefs for the duration of the server session unless they are removed using link::Classes/CodexHybrid#-removeSynthDefs::. In CodexHybrid, the method teletype::-reloadScripts:: is overloaded to include teletype::-removeSynthDefs:: so that SynthDefs are updated on the server as the modules themselves are updated. 

note:: To ensure that SynthDef names are accessed consistently, it is best not to hardcode the names of SynthDefs either into any modules or class implementations. Rather, calling the method link::Classes/SynthDef#-name#-name:: on the associated SynthDef module will produce more consistent results.
code::
	~someHybrid.modules.synthDef.name;
::
::

section::HybridExample
The below implementation example builds upon the previous one by defining a SynthDef module and replacing the pattern module with a custom template called "patternFunction", which, as its name suggests, returns a function that itself returns a pattern. 

Also, note that that the method teletype::initComposite:: has been replaced with teletype::initHybrid::. The reason for this change is due to the fact that CodexHybrid engages its specialized procedures in the method teletype::initComposite::, making it unavailable. Nevertheless, given that teletype::-initHybrid:: is called upon after the completion of these procedures, it plays an equivalent role for the subclasses of CodexHybrid as teletype::initComposite:: plays for all other subclasses of CodexComposite. 

code::
HybridExample : CodexHybrid {
	var player;

	//Note the usage of the contribution method, which points to modules 
	//that are automatically copied to the class folder.
	*contribute { | versions |
		var toQuark = Main.packages.asDict.at(\CodexIan);
		var toExample = toQuark+/+"Classes/Examples/Modules";

		versions.add(
			[\example, toExample]
		);
	}

	initHybrid {}

	*makeTemplates { | templater |
		templater.hybridExampleFunction( "sequence" );
		templater.synthDef( "synthDef" );
	}

	play {
		if(player.isPlaying.not, {
			player = modules.sequence.play;
		});
	}

	stop {
		if(player.isPlaying, {
			player.stop;
		});
	}
}
::
subsection::Usage
Here is an outline of how to interact with the HybridExample class. It should make sounds.

code::
//Inspect existing module sets
HybridExample.moduleSets.postln;

//Instance a new HybridExample.
s.waitForBoot({ x = HybridExample.new(\example) });

//Inspect the modules.
x.modules.postln;

//Inspect the name of the SynthDef.
x.modules.synthDef.name.postln;

//Play it to hear sounds. 
x.play;

//Clone a new moduleSet to observe the new SynthDef name.
x.moduleSet_(\example2, \example);
x.modules.synthDef.name.postln;

//Play it to hear sounds.
x.play;
::
