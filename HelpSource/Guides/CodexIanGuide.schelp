TITLE::CodexIan Guide
summary:: Guide to working with the CodexComposites and CodexHybrids
categories:: Libraries>CodexIan

section::Overview
CodexIan is a library of classes designed to support an approach to music making in sclang that combines the specificity of a compiled class's interface with the open-ended potential of scripting. The basic idea for the library is that a class written using its features only has to describe high-level interactions between swappable components whose definitions are arbitrary. For instance, a class written to sequence patterns in a routine might implement only the routine and the leave the patterns to be loaded from external scripts called modules. As a result, the patterns of this example can be redefined at any point and put to use without the need for recompiling sclang. link::Classes/CodexComposite:: coordinates these operations and maintains a directory of collections of modules, which it can load, unload, clone, and template on behalf of its subclasses. link::Classes/CodexHybrid::, which inherits from CodexComposite, handles sending and removing link::Classes/SynthDef:: modules from a given server. A description of how to work with both classes is described in the following guide.

section::Module directories

Each class that inherits from CodexComposite will have its modules stored in a central directory on the machine. The modules themselves are organized in layers of subfolders that are specified on a per-class-per-collection basis. The path to the directory can be gotten and set through through link::Classes/Composite#*directory::. If the path to the directory of modules is reset, the new configuration will persist across sessions of the link::Classes/Interpreter:: (see link::Classes/CodexPaths::).

note::Be sure to configure the path to the modules directory. By default, the module directory is stored in the folder of this quark. 
code:: 
//Check where the directory is. 
CodexComposite.directory.postln; 

//Replace this path with something you prefer.
CodexComposite.directory = "~/Documents/sc-modules".standardizePath;
::
::
An outline of the directory looks like this: 

Module Directory
tree::
	##Class 0
		tree::
			##Module folder
				tree::
					##Module
					##Module
					##Module
				::
			##Module folder
				tree::
					##Module
					##Module
					##Module
				::
		::
	##Class 1
		tree::
			##Module folder
			tree::
				##Module
			::
		::
::

subsection::Class folders
Class folders are generated automatically. However, the circumstances of when that happens varies depending on the implementation of the class whose modules a given class folder is storing. For instance, if you are developing a class that inherits from CodexComposite and want it to ship with a set of default modules, overwriting the method link::Classes/CodexComposite#*defaultModulesPath:: so that it returns a path to your defaults will make CodexComposite create a class folder entry in the directory as well as a subfolder called "default" containing copies of those modules. This will happen the first time your new class is compiled with that overloaded method and every subsequent time sclang is recompiled when either the class folder or the default modules' folder does not exist. That said, if no default modules are specified, the first time a class is instanced, an entry will be made in the directory for the class and a modules folder filled with templates will be generated.

subsection::Module folders
Modules are stored as teletype::.scd:: files in subfolders of each class folder where each of these subfolders contains variations of the modules templated by the class. In this way, a class expects that modules representing specific sclang objects exists but not how they exist. As such, a pattern contained within a file called teletype::sequence.scd:: in a folder called teletype::default:: can be implemented differently than pattern within a file of the same name but in a folder called teletype::experimental:: so long as both files return an object of the same type. In other words, each folder of modules contains variations of the same basic set of files. Furthermore, there is no practical limit to the number of variations of collections of modules that can exist per class. An instance of a subclass of CodexComposite is told to load one of these collections in two ways. The first is achieved by supplying either a relative name to the teletype::moduleSet:: argument of link::Classes/CodexComposite#*new:: in the form of a symbol or string, and the second by setting the value of the field link::Classes/CodexComposite#-moduleSet::. In either circumstance, the user has an opportunity to point to a different set of modules using the argument teletype::from::. In the case where the new set of modules does not already exist and the second set does, the first set will be cloned from the second. If no second collection of modules is specified or does not exist, the new collection of modules will be generated from link::Classes/CodexTemplater##templates::.

subsection::Modules
As stated above, modules are teletype::.scd:: files containing scripts that return an arbitrary object. When a collection of modules is requested for the first time, these scripts are loaded into sclang, collected as an link::Classes/Event::, and stored in an instance of link::Classes/CodexCache::. Copies of these modules are then made available to the instance and can be accessed via link::Classes/CodexComposite#-modules::. The name of each respective module is taken from the name of its source file. For instance, a pattern loaded from teletype::sequence.scd:: will be stored in the modular event using the key \sequence. Moreover, if the name of the file were teletype::SillySequence.scd::, its associated module would be stored in the modular event under the key \sillySequence.

If the source file of a module is edited during the course of using a subclass of CodexComposite, simply calling link::Classes/CodexComposite#-reloadScripts# will reload the scripts both into the cache and into the instance. As a result, all new instances of that same subclass using the same set of modules will reflect these updates. Furthermore, it is not necssary to recompile sclang.


section::Development Example
Developing a class that inherits from CodexComposite is relatively simple. No constructor is need. The only requirement is that the developer fill out the method link::Classes/CodexComposite#*makeTemplates::, which takes in an instance of link::Classes/CodexTemplater:: as an instance. It is in this method where the modules are defined. For instance, if you are making a class that requires a pattern that will be accessed in the event of modules via the key \sequence, telling the templater instance must be told to make a pattern template with the name "sequence". This is demonstrated below.

code::
CompositeExample : CodexComposite {
	var player;
	
	//initComposite is called immediately after modules are loaded into the class. 
	//Initialize instance variables here if you don't want to rewrite the constructor.
	initComposite {}

	//The only actual requirement for developing CodexComposite-typed classes is to define the modules that make up the composite.
	//This is done in the method makeTemplater. CodexComposite holds an instance of Templater called templater for this purpose.
	//If a specific template is not available, extend Templater to make it.
	*makeTemplates { | templater | 
		templater.pattern( "sequence" );
	}

	//Here is an example of how to interact with the modules. 
	//The class expects that the collection of modules will have an item \sequence because it was specified by the templater. 
	//Because it expects that that item is a pattern, it can have .play called on it. 
	//It can, therefore, also be stopped.
	play { 
		player = modules.sequence.play;
	}

	stop { 
		player !? { 
			player.stop; 
			player = nil;
		}
	}

}
::

subsection::Usage Example
code::
x = CompositeExample.new;

//Insepct the modules.
x.modules.postln;

(
//If above was the first time that CompositeExample was instanced, note that an entry now exists in the module directory.
var path = CodexComposite.directory;
PathName(path).folders.do({|item|
	item.folderName.postln;
});
)

(
//Inspecting that folder, see that an entry exists called default by default.
var path = CodexComposite.directory+/+"CompositeExample";
PathName(path).folders.do({|item|
	item.folderName.postln;
});
)

(
//Inspecting default, we see that there is a .scd file corresponding with the template defined in the class.
var path = CodexComposite.directory+/+"CompositeExample"+/+"default";
PathName(path).files.do({|item|
	item.fileName.postln;
});
)

//If you want to make a new set of modules, that is easy.
x.moduleSet = \experimental;

//Inspect the modules.
x.modules.postln;

(
//See that not only does the new folder experimental exist, but it is populated with correctly named module templates.
var path = CodexComposite.directory+/+"CompositeExample"+/+"experimental";
PathName(path).files.do({|item|
	item.fileName.postln;
});
)

//You can switch back and forth between existing modules too.
x.moduleSet = \default;

(
//Note here that no new folder was made.
var path = CodexComposite.directory+/+"CompositeExample";
PathName(path).folders.do({|item|
	item.folderName.postln;
});
)

//If you want to make a new folder cloned from the experimental one... 
//edit the file in the \experimental folder, and clone it as follows: 
x.moduleSet_(\exp2, \experimental);

(
//See that the new folder exists. Because experimental was created from templates, though, unless you edited it yourself in the meantime, the new folder will also be a copy of templates.
var path = CodexComposite.directory+/+"CompositeExample";
PathName(path).folders.do({|item|
	item.folderName.postln;
});
)
::
subsection::Limits of example
There is a problem with this example. While teletype::CompositeExample:: works silently from its templates of patterns, the class does not define the server resources that these patterns would refer to throughout their operation. While it might seem simple enough to template some ammending teletype::SynthDef:: modules, this in turn raises certain procedural questions. For instance, how would a composite coordinate server and client resources given the link::Guides/Sync-Async##asynchronicity:: between the two? How would it manage a situation in which two of its instances referred to two differnt teletype::moduleSets:: that ostensibly overwrote the same teletype::SynthDef::?

A simple solution to these issues is implemented by link::Classes/CodexHybrid::.

SECTION::CodexHybrid
teletype::CodexHybrid:: extends the procedures of teletype::CodexComposite:: to handle circumstances where a teletype::CodexComposite::-typed class uses resources on both the client and the server. Specifically, the class deals with loading and unloading teletype::SynthDefs::. These operations were designed with efficiency in mind: once a teletype::SynthDef:: is loaded onto the server, a reference to it is stored in a dictionary maintained by the class. The class checks this dictionary before loading teletype::SynthDefs::, ensuring that teletype::SynthDefs:: are added to the server only once per server session rather than every time a given hybrid is instanced.

subsection::SynthDef naming
teletype::CodexHybrid:: takes on the role of formatting teletype::SynthDef:: names for two purposesâ€”to prevent overwriting resources critical to the function of a given subclass of teletype::CodexHybrid:: and to give multiple instances of the same teletype::CodexHybrid::-typed class simultaneous access to different teletype::moduleSets:: that use teletype::SynthDefs:: defined using the same name. In this way, teletype::CodexHybrid:: reformats teletype::SynthDef:: names as follows: strong::ClassName_ModuleSet_OriginalName::.

For example, if an example class defines a teletype::SynthDef:: with the name teletype::\helloWorld::, when the default teletype::moduleSet:: is loaded, that teletype::SynthDef's:: name will be reformatted, stored, and sent to the server with the symbol teletype::\ExampleClass_default_helloWorld::. If the teletype::moduleSet:: teletype::\experimental:: were cloned from the default set and loaded for the first time, its teletype::SynthDef's:: name would be reformatted, stored, and sent to the server with the symbol teletype::\ExampleClasas_experimental_helloWorld::. However, once these teletype::moduleSets:: are loaded, the class will not reload them for the duration of the server session unless they are cleared from the user by using link::Classes/CodexHybrid#*freeSynthDefs:: or link::Classes/CodexHybrid#*clearDictionary::.

If a teletype::SynthDef:: name is set with any of these component parts before formatting, that part will not be reformatted. For instance, the teletype::symbol \ExampleClass_SynthDef:: will be reformatted to teletype::\ExampleClass_default_SynthDef:: if called by a teletype::moduleSet:: with the key teletype::\default::. Moreover, if the teletype::SynthDef:: were defined with the name teletype::\ExampleClass_default_SynthDef::, it will not be reformatted when called with the default key. However, if it were called from the teletype::moduleSet \experimental::, it would be changed to teletype::\ExampleClass_experimental_default_SynthDef::.

As a result, when defining teletype::SynthDefs:: in modules, the user does not need to worry about assigning unique names at all. Because all teletype::SynthDefs:: are accessible as modules, finding its name is as simple as follows:
code::
	~composite.modules.synthDef.name.
::
This will work regardless of what teletype::moduleSet:: is active in a hybrid.

section::Development example
The only differences between the below implementation and the one above is the fact that this example inherits from teletype::CodexHybrid:: and defines three teletype::SynthDef:: modules. Now the class can function like anoy other hybrid.
code::
HybridExample : CodexHybrid {
	var routine, pattern;

	initCodexHybrid {}

	//Templater has been extended to make "patternFunctions", which are functions that return patterns.
	//This is necessary for passing in the SynthDef's name into the pattern
	makeTemplates {
		templater.patternFunction( "sequence0" );
		templater.patternFunction( "sequence1" );
		templater.patternFunction( "sequence2" );
		//Three SynthDefs...
		templater.synthDef( "synthDef0" );
		templater.synthDef( "synthDef1" );
		templater.synthDef( "synthDef2" );
	}

	play {
		routine = fork{
			pattern = modules.sequence0.play;
			2.wait;
			pattern.stop;
			pattern = modules.sequence1.play;
			2.wait;
			pattern.stop;
			pattern = modules.sequence2.play;
			2.wait;
			pattern.stop;
		};
	}

	stop {
		routine.stop;
		pattern.stop;
	}
}
::
section::Usage example
Here is an outline of how to interact with the teletype::HybridExample:: class. It should make sounds.

code::
x = HybridExample.new;

//Inspect the modules.
x.modules.postln;

//Inspect the dictionary of SynthDefs maintained by CodexHybrid.
x.class.dictionary.postln;

//Clone a new moduleSet to observe the new SynthDef names.
x.moduleSet_(\experimental, \default);
x.class.dictionary.postln;
x.modules.postln;

//Play it to hear sounds.
x.play;

::

